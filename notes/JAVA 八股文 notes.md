# JAVA 八股文 notes

collected by wxb



## Ch 1. 基础语法

### 1.1 基本数据结构

**==6种数字类型，1种字符类型，1种布尔类型 => 共8种基本数据类型==**

#### 1.1.1 基本数据类型总览

* 整数类型：byte, short, int, long
* 浮点数类型：double, float
* 字符类型：char (使用统一码对字符编码)
* 布尔类型：boolean

| 基本数据类型 | 存储大小                       | 取值范围                                                     | 默认值   |
| ------------ | ------------------------------ | ------------------------------------------------------------ | -------- |
| byte         | 8 bit 有符号数                 | -2^7^-2^7^-1                                                 | 0        |
| short        | 16 bit 有符号数                | -2^15^-2^15^-1                                               | 0        |
| int          | 32 bit 有符号数                | -2^31^-2^31^-1                                               | 0        |
| long         | 64 bit 有符号数                | -2^63^-2^63^-1                                               | 0L       |
| float        | 32 bit<br />符合IEEE 754标准   | 负数：-3.402823e+38 - -1.401298e-45<br />正数：1.401298e-45 - 3.402823e+38 | 0.0f     |
| double       | 64 bit<br />符合 IEEE 754 标准 | 负数：-1.797693e+308 - -4.9000000e-324<br />正数：4.9000000e-324 - 1.797693e+308 | 0.0d     |
| char         | 16 bit                         | 0-2^16^-1                                                    | '\u0000' |
| boolean      | 1 bit                          | true / false                                                 | false    |

#### 1.1.2 数字类型直接量

直接量：程序中直接出现的常量值，如`500, 3.14`

##### 整数类型直接量

* 默认类型：`int`

* 赋值给整型变量时

    * 若超出变量取值范围：编译错误

        => 必须在其后加上`L(l)`，将该直接量显性声明为`long`

    * 若在变量取值范围内：直接赋值

##### 浮点类型直接量

* 默认类型：`double`

* 赋值给 `float` 时：

    * `double` 直接给`float`赋值：编译错误

        => 必须在其后加上`F(f)`，将该直接量显性声明为 `float`

#### 1.1.3 基本数据类型间的转换

布尔类型不能与其他基本数据类型进行转换

##### 数字类型间的转换

范围从小到大：`byte` < `short` < `int` < `long` < `float` < `double`

* **拓宽类型**：将小范围类型变量转换为大范围类型

    => **不需要显性声明**

* **缩窄类型**：将大范围类型变量转换为小范围类型

    => **必须显性声明，否则编译错误**

##### 字符类型与数字类型的转换

* 字符类型 => 数字类型
    * 字符的统一码转换成指定的数值类型
    * 如果字符的统一码超出转换成的数值类型的取值范围，则必须显性声明类型转换
* 数字类型 => 字符类型
    * 浮点数类型将整数部分转换成字符类型
    * 只取整数的低16位

#### 1.1.4 练习题

> 以下写法中，会导致编译错误的是？
>
> A. byte b = 30;
>
> B. byte b = 500;
>
> C. long l = 2343223;
>
> D. float f = 3.14;

```typescript
answer: B, D
/* B: 500 超出了 byte 类型的取值范围，会导致编译错误。
 * D: 3.14 是 double 型直接量，不能赋值给 float 类型的变量。*/
```

> 以下写法中，会导致编译错误的是？
>
> A. byte b = 'b';
>
> B. byte b = (byte) 'b';
>
> C. short s = '\u8000';
>
> D. short s = (short)'\u8000';

```jsx
answer: C
/* 将字符类型转换成数字类型时，字符的统一码转换成指定的数值类型，
 * 此时需要判断字符的统一码是否超出转换成的数值类型的取值范围。
 * C: 字符直接量超出了 short 的取值范围且没有显性声明类型转换，会导致编译错误。*/
```

> 哪一种基本数据类型不能和其他基本数据类型进行类型转换?

```
布尔类型
```

-------------

### 1.2 方法

方法（过程，函数）：为执行一个操作而组合在一起的语句组。

#### 1.2.1 方法的语法结构

方法 = 方法头 + 方法体

* 方法头 = 修饰符 (alter) + 返回值类型 + 方法名 + 参数列表 (alter 参数类型、次序和数量)

方法签名 = 方法名 + 参数表

#### 1.2.2 参数的值传递

* 参数顺序匹配：次序和数量匹配，**类型要兼容 (无需显示转换)**
* 只有值传递
    * 参数类型是基本数据类型：不会对实参进行修改
    * 参数类型是对象时，传递的是对象的引用，可以对实参引用的对象进行修改，但是不能让实参引用新对象

#### 1.2.3 方法的重载 Overload

* 方法重载：在同一个类中的多个方法有相同的名称，但方法签名不同，编译器根据方法签名决定调用哪个方法。

    = 多个方法同名，参数列表不同

* 增加程序可读性

* 不能通过修饰符和返回值类型进行重载

* 如果一个方法调用有多个可能的匹配，编译器会选择最合适的匹配方法

    若编译器无法判断，则为**歧义调用**，会导致编译错误

--------------

### 1.3 递归

递归：直接或间接调用自身的方法

#### 1.3.1 递归的要点

* 定义递归方法时需要定义 递归的初始状态、初始状态的处理 和 递归调用
* 保证所有递归调用都能达到初始状态 (终止条件)，否则会发生无限递归，导致栈溢出
* 非初始状态：进行递归调用，对子问题求解

**尾递归：**递归调用是方法中最后执行的语句，且返回值不属于表达式的一部分

* 在返回时直接传回原始的调用者，而不用经过中间的调用者
* 使用尾递归代替普通的递归，可以在时间和空间方面带来显著提升

#### 1.3.2 递归的优缺点

优点：代码简洁，容易理解

缺点

* 时间、空间消耗大

    * 调用函数时参数的入栈出栈都要额外时间开销

    * 由于栈空间有限，递归调用次数太多可能导致调用栈溢出

* 如果子问题存在重叠，在不加记忆化的情况下，递归会产生重复计算

> 可以通过什么方式解决递归的缺点？

```jsx
/* 尾递归
 * 加记忆化，避免重复计算
 * 改用迭代实现
 */
```





## Ch 2 面向对象

### 2.1 面向对象的概念

#### 2.1.1 面向对象和面向过程

**面向过程**

* 将问题分解成步骤，然后按照步骤实现函数，执行时依次调用函数。
* 数据和对数据的操作是分离的。
* 优点：性能更高，不需要面向对象的实例化。
* 缺点：不容易维护、复用和扩展。

**面向对象**

* 将问题分解成对象，描述事物在解决问题的步骤中的行为。
* 对象与属性和行为是关联的。
* 优点：具有封装、继承、多态的特性，容易维护、复用和扩展，可以设计出低耦合的系统。
* 缺点：需要实例化对象，性能较低

#### 2.1.2 对象和类

对象

* 现实世界中可以明确标识的实体。
* 有自己独有的状态 (数据域的集合) 和行为 (方法的集合)。

类

* 定义同一类型对象的结构，是对具有相同特征的对象的抽象。
* 是一个模板，用来定义对象的数据域和方法。
* 可以从一个类创建多个对象，创建对象称为实例化。

-----------------

### 2.2 构造方法

调用构造方法可以创建新对象。实际应用中，一般用于初始化。

#### 2.2.1 定义和调用构造方法

* 构造方法的名称必须和其所在类的名称相同
* 构造方法没有返回类型
* 构造方法可以被重载 (参数列表可以不同)
* 使用 `new` 调用构造方法创建对象

#### 2.2.2 默认构造方法

* 可以不显式声明 => 类中会隐性声明一个方法体为空的无参构造方法 (默认构造方法)

-----------------

### 2.3 静态和实例

* 类成员：类中的成员变量、方法
* 使用 `static` 修饰的类成员是静态的类成员，不适用 `static` 修饰的即为实例的类成员

#### 2.3.1 静态和实例的区别

|          | 静态                         | 实例                               |
| -------- | ---------------------------- | ---------------------------------- |
| 外部调用 | 通过类名或对象名调用均可     | 只能通过对象名调用                 |
| 内部访问 | 静态方法只能访问静态的类成员 | 实例方法可以访问静态或实例的类成员 |

> 为什么静态方法不能访问实例的类成员呢?
>
> 原因：实例的类成员是依赖于具体对象（实例）的，而静态方法不依赖于任何实例，因此不存在静态方法直接或间接地访问实例或实例的类成员的情况。

#### 2.3.2 判断使用静态或实例

**类成员是否依赖于具体实例**

* 如果依赖于具体实例，类成员必须是实例
* 否则，应该被定义为静态类成员，例如 `Math` 类中的所有类成员都是静态的

-------------------------

### 2.4 初始化块

* 代码初始化块属于类成员
* 在 加载类 或 创建对象 时会隐式调用代码初始块
* 优点：减少多个构造器内的重复代码

#### 2.4.1 初始化块的分类

* **静态初始化块**：在**加载类**时被隐式调用

    ```java
    static {
      ...
    }
    ```

* **非静态初始化块**：在**创建对象**时被隐式调用

    ```java
    {
      ...
    }
    ```

#### 2.4.2 单个类的初始化块执行顺序

==静态初始化块 => 非静态初始化块 => 构造器==

如果有初始化块，则初始化块会在其他代码之前被执行

* 静态初始化块

    * 会在静态方法之前被执行

        => 静态初始化最先执行，且只执行一次，在`main`方法之前

* 非静态初始化块

    * 会在构造器和实例方法之前被执行

        => 每次创建对象都会执行

#### 2.4.3 存在继承关系的初始化块执行顺序

> 如果存在继承关系，则在对子类进行类的加载和创建对象时，也会对父类进行类的加载和创建对象。

执行顺序规则

1. 按照从父类到子类的顺序，依次执行每个类的静态初始化块。
2. 按照从父类到子类的顺序，对于每个类，依次执行非静态初始化块和构造器，直到所有类执行完毕。

--------------------

### 2.5 关键字 this

* `this` 代表当前 (具体) 对象的引用
* 因为静态方法和静态初始化块不依赖于类的具体对象，所以 `this`静态方法和静态初始化块中不能使用 `this`

#### 2.5.1 `this` 引用隐藏变量

当方法 (包括构造方法)中有参数、局部变量和属性名相同时，需要用 `this` 引用对象的属性进行赋值。例：`this.name = name;`

如果没有重名，则可以省略属性名前的 `this`

#### 2.5.2 `this` 调用其他构造方法

* 可以在构造方法中通过 `this` 调用其他构造方法
* 用法：`this(params list)`，且必须出现在其他语句之前

--------------------------

### 2.6 可见性修饰符和数据域封装

可见性修饰符：控制对类成员的访问

* `public`, `private`, `protected`, 默认修饰符

#### 2.6.1 不同的可见性修饰符的含义

* `public` 无访问限制
* `private` ：类内访问
* 默认修饰符：包私访问、包内访问

#### 2.6.2 数据域封装

数据域封装：对数据域使用 `private` 修饰符，将数据域声明为私有域，不允许从类的外部修改。

* 使用 `private` 修饰数据域
* 编写 `get` 和 `set` 方法用于返回和设置数据域的值

---------------------------------

### 2.7 字符串

`String`, `StringBuffer`, `StringBuilder`

#### 2.7.1 String

不可变类型，适用于字符串常量

* 使用字符数组存储，并使用 `final` 修饰 (final修饰的引用不可以指向其他对象)

* 数组声明为 private，且没有对外提供修改的方法，所以字符串对象无法修改

    => `String` 定义的字符串的值不可变

    => 每次对 `String` 的修改操作都会创建新的 `String` 对象

    => 效率低下，占用大量内存

#### 2.7.2 StringBuffer 和 StringBuilder

可变类型，适用于需要经常对字符串内容进行修改的情况

* 都是 `AbstractStringBuilder` 的子类，使用字符数字存储，没有使用 `final` 修饰

    => 字符串内容可以修改，不会因为修改二而创建新的对象

    => 时间和空间上都显著优于 `String`

* 区别

    * `StringBuffer` 使用 `synchronized` 修饰了定义或调用的方法，加了同步锁

        => 效率较低，但多线程环境下更安全

    * `StrngBuilder` 没有用 `synchronized` 修饰定义或调用的方法

        => 效率更高，但多线程环境下不能保证线程安全，只适用于单线程环境

----------------------------

### 2.8 继承

继承：从已有的父类派生出新的子类

#### 2.8.1 父类和子类

* 子类从父类继承可以访问的类成员
* 子类可以添加新的类成员
* 若在定义类时没有指定继承，则其父类默认是 `Object`
* 一个类只能继承一个父类

#### 2.8.2 关键字 super

关键字 `super`：指向当前类的父类

* 调用父类的构造方法

    使用：`super(params list)`，且必须是子类构造方法的第一个语句

    是调用父类构造方法的唯一方式

* 调用父类的方法

    使用：`super methodName(param list)`

#### 2.8.3 构造方法链

构造方法链：构造类实例时，会**沿着继承链调用所有父类的构造方法 (从父到子)**

如果构造方法没有显示调用同一个类中的其他构造方法或父类的构造方法，将隐性调用父类的无参数构造方法，即编译器会把 `super()` 作为构造方法的第一个语句。

#### 2.8.4 方法的重写 Override

方法重写：子类修改了父类定义的方法

* 子类的方法和父类的方法签名相同，即方法名和参数列表相同
* 如果方法返回值类型是基本数据类型或`void`，要求重写的方法与父类方法返回值相同
* 如果方法返回值类型是引用类型，要求重写的方法返回值相同或为其子类
* 静态方法：可以被继承，不能被重写
* 实例方法：只有可访问时才能被重写。因此私有方法不能被重写

#### 2.8.5 重写和重载的区别

* 重载：同一个类中定义多个方法，方法名相同，参数列表不同，返回值可以不同
* 重写：子类中定义一个与父类方法签名相同的方法，返回值类型相同或为父类中方法返回类型的子类

#### 2.8.6 可见性修饰符 protected

`protected`：包内访问 + 子类访问

* 子类可以覆盖父类的`protected`方法，并把该方法改成 `public`
* 子类不能降低父类方法的可见性，即不能把 `public` 方法改成 `protected`

==public > protected > 默认 > private==

#### 2.8.7 关键字 final

* 用于声明常量，表示常量不会改变
* 用于修饰类，表示类是终极类，不能被继承
* 用于修饰方法，表示方法不能被子类重写

------------------

### 2.9 Object 类的部分方法

#### 2.9.1 toString

`public String toString()`

返回一个代表该对象的字符串，默认实现为空，通常需要在子类中重写

#### 2.9.2 equals

`public boolean equals(Object obj)`

默认实现是用 `==` 检验两个对象是否相等（判断的是引用值），如果要判断对象内容，通常需要在子类中重写

#### 2.9.3 hashCode

`public native int hashCode`

返回对象的散列码。关键字 `native` 表示实现方法的编程语言不是 Java。

如果两个对象相同，它们的散列码一定相同，因此如果在子类中重写了 `equals` 方法，必须在该子类中重写 `hashCode` 方法，以保证两个相等的对象的散列码相同。

实现 `hashCode` 方法时，应避免过多出现两个不同的对象具有相同的散列码的情况。

#### 2.9.4 finalize

`protected void finalize() throws Throwable`

用于垃圾回收 (如果一个对象不能再被访问，就是垃圾)

`finalize` 会被该对象的垃圾回收程序调用，默认为空，如有必要，应重写

可能抛出 `Throwable` 异常

#### 2.9.5 clone

`protected native Object clone() throws CloneNotSupportedException`

 用于复制对象，创建一个有单独内存空间的新对象

但不是所有对象都可以复制，只有实现了 `java.lang.Cloneable` 接口的类的对象才能被复制

可能抛出 `CloneNotSupportedException`

#### 2.9.6 getClass

`public final native Class <?> getClass()`

返回对象的元对象 (包含类信息的对象，包括类名、构造方法和方法)

一个类只有一个元对象，每个对象都有一个元对象，同一个类的多个对象对应的元对象相同

-----------------

### 2.10 抽象类和接口

抽象类：抽象、没有具体实例的类。

接口：与类相似的结构。

#### 2.10.1 抽象类

* 使用关键字 `abstract` 修饰

* 和常规类一样有数据域、方法和构造方法，但是不能用 `new` 操作创建实例

* 可以包含抽象方法。

    > 抽象方法用关键字 `abstract` 修饰，只有方法签名而没有实现。具体实现由子类提供。抽象方法都是非静态的。包含抽象方法的类必须声明为抽象类。

    如果一个子类不能实现所有的抽象方法，则该子类也必须声明为抽象类。

#### 2.10.2 接口

* 使用关键字 `interface` 定义
* 只可包含 `public` 的**常量和抽象方法**，不包含变量和具体方法，不能用 `new` 创建实例
* **版本变动**
    * 从 Java 8 开始，接口方法可以由默认实现。
    * 从 Java 9 开始，接口内允许定义私有方法。
* 多重继承：一个类可以实现多个接口，一个接口可以继承多个接口

#### 2.10.3 抽象类和接口的区别

* 抽象类的变量无限制，接口只包含常量，即接口的所有变量必须是 `public static final`
* 抽象类包含构造方法，子类通过构造方法链调用构造方法，接口不包含构造方法
* 抽象类的方法无限制，接口的方法必须是`public abstract `的实例方法 (有版本变动)
* 抽象类和常规类都只能单重继承，但是可以实现多个接口，一个接口可以继承多个接口

#### 2.10.4 自定义比较方法

`Comparable` 接口：排序接口，包含一个`compareTo`抽象方法。

* 如果类实现了`Comparable` 接口，则该类的对象可以排序
* 实现`Comparable` 接口需要实现`compareTo`抽象方法

`Comparator` 接口：比较器接口，包含两个抽象方法 `compare` 和 `equals`

* 一个类本身不支持排序（即没有实现 `Comparable` 接口），但是又需要对该类的对象排序，则可以通过实现 `Comparator` 接口的方式建立比较器。
* `compare` 方法必须在实现类中实现，`equals` 方法在任何类中默认已经实现

> 如何对一个数组中的多个对象按照不同的依据进行排序?
>
> 为了按照不同的依据进行排序，则需要使用不同的比较器，通过实现 Comparator 接口实现比较器，在调用 Arrays.sort 方法时将数组和比较器作为参数，即可将数组按照指定的比较器进行排序。

### 2.11 基本数据类型和包装类

包装类：把基本数据类型包装成对象，对应的类称为包装类。包装类的实例都是不可变的，一旦创建，内部值就不能改变。

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| short        | Short     |
| float        | Float     |
| double       | Double    |
| char         | Character |
| boolean      | Boolean   |

#### 2.11.1 包装类的构造方法

* 调用包装类的构造方法可以创建包装类的对象
* 包装类的构造方法都有参数，没有无参数的构造方法
* 构造方法的参数值可以是基本数据类型的值，也可以是表示值的字符串

#### 2.11.2 自动装箱和自动拆箱

- 装箱：基本数据类型的值转换为包装对象
- 拆箱：包装对象转换为基本数据类型的值
- 从 JDK 1.5 开始，基本数据类型和包装类之间可以进行自动转换。

### 2.12 面向对象思想

#### 2.12.1 类的关系

**关联**：描述两个类之间行为的一般二元关系

* 关联中的每个类可以指定一个数字或一个数字区间，表示该关联涉及类中的多少个对象。
* 关联可以用数据域和方法进行实现，一个类中的方法包含另一个类的参数。

**聚集**：一种特殊的关联形式，表示两个对象之间的所属关系 (has-a)

* 所有者对象称为聚集对象，对应的类称为聚集类

    从属对象称为被聚集对象，对应的类称为被聚集类

* 一个对象可以被几个聚集对象所拥有。

**组合**：一种特殊的聚集关系，一个对象被一个聚集对象所专有

**依赖**：两个类之间一个类使用另一个类的关系，client 使用 supplier

* 实现依赖的方式：client 类中的方法包含 supplier 类的参数。

**继承**：is-a

- **strong is-a**：两个类之间的直接继承关系，用类的继承表示
- **weak is-a**：一个类具有某些属性，用接口表示

#### 2.12.2 类的设计原则

**内聚性**

* **高内聚**：同一个类/模块的所有操作应有高度关联性，支持共同的目标，只负责一项任务，即单一责任原则
* **低耦合**：不同类/模块之间的关联程度尽量低，对一个类/模块的修改应尽量减少对其他类/模块的影响

**封装性**

* 类中的数据域应使用 `private` 修饰符隐藏其可见性，避免从外部直接访问
* 使用 `getter` 和 `setter` 获得或设置数据域的值
* 如果一个方法只在类的内部使用，则应用 `private` 修饰，避免外部调用

**实例和静态**

如果一个数据域被所有实例共享，该数据域应声明为静态数据域。如果一个方法不依赖于具体实例，该方法应声明为静态方法。

