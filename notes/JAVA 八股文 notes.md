# JAVA 八股文 notes

collected by wxb



## Ch 1. 基础语法

### 1.1 基本数据结构

**==6种数字类型，1种字符类型，1种布尔类型 => 共8种基本数据类型==**

#### 1.1.1 基本数据类型总览

* 整数类型：byte, short, int, long
* 浮点数类型：double, float
* 字符类型：char (使用统一码对字符编码)
* 布尔类型：boolean

| 基本数据类型 | 存储大小                       | 取值范围                                                     | 默认值   |
| ------------ | ------------------------------ | ------------------------------------------------------------ | -------- |
| byte         | 8 bit 有符号数                 | -2^7^-2^7^-1                                                 | 0        |
| short        | 16 bit 有符号数                | -2^15^-2^15^-1                                               | 0        |
| int          | 32 bit 有符号数                | -2^31^-2^31^-1                                               | 0        |
| long         | 64 bit 有符号数                | -2^63^-2^63^-1                                               | 0L       |
| float        | 32 bit<br />符合IEEE 754标准   | 负数：-3.402823e+38 - -1.401298e-45<br />正数：1.401298e-45 - 3.402823e+38 | 0.0f     |
| double       | 64 bit<br />符合 IEEE 754 标准 | 负数：-1.797693e+308 - -4.9000000e-324<br />正数：4.9000000e-324 - 1.797693e+308 | 0.0d     |
| char         | 16 bit                         | 0-2^16^-1                                                    | '\u0000' |
| boolean      | 1 bit                          | true / false                                                 | false    |

#### 1.1.2 数字类型直接量

直接量：程序中直接出现的常量值，如`500, 3.14`

##### 整数类型直接量

* 默认类型：`int`

* 赋值给整型变量时

    * 若超出变量取值范围：编译错误

        => 必须在其后加上`L(l)`，将该直接量显性声明为`long`

    * 若在变量取值范围内：直接赋值

##### 浮点类型直接量

* 默认类型：`double`

* 赋值给 `float` 时：

    * `double` 直接给`float`赋值：编译错误

        => 必须在其后加上`F(f)`，将该直接量显性声明为 `float`

#### 1.1.3 基本数据类型间的转换

布尔类型不能与其他基本数据类型进行转换

##### 数字类型间的转换

范围从小到大：`byte` < `short` < `int` < `long` < `float` < `double`

* **拓宽类型**：将小范围类型变量转换为大范围类型

    => **不需要显性声明**

* **缩窄类型**：将大范围类型变量转换为小范围类型

    => **必须显性声明，否则编译错误**

##### 字符类型与数字类型的转换

* 字符类型 => 数字类型
    * 字符的统一码转换成指定的数值类型
    * 如果字符的统一码超出转换成的数值类型的取值范围，则必须显性声明类型转换
* 数字类型 => 字符类型
    * 浮点数类型将整数部分转换成字符类型
    * 只取整数的低16位

#### 1.1.4 练习题

> 以下写法中，会导致编译错误的是？
>
> A. byte b = 30;
>
> B. byte b = 500;
>
> C. long l = 2343223;
>
> D. float f = 3.14;

```typescript
answer: B, D
/* B: 500 超出了 byte 类型的取值范围，会导致编译错误。
 * D: 3.14 是 double 型直接量，不能赋值给 float 类型的变量。*/
```

> 以下写法中，会导致编译错误的是？
>
> A. byte b = 'b';
>
> B. byte b = (byte) 'b';
>
> C. short s = '\u8000';
>
> D. short s = (short)'\u8000';

```jsx
answer: C
/* 将字符类型转换成数字类型时，字符的统一码转换成指定的数值类型，
 * 此时需要判断字符的统一码是否超出转换成的数值类型的取值范围。
 * C: 字符直接量超出了 short 的取值范围且没有显性声明类型转换，会导致编译错误。*/
```

> 哪一种基本数据类型不能和其他基本数据类型进行类型转换?

```
布尔类型
```

-------------

### 1.2 方法

方法（过程，函数）：为执行一个操作而组合在一起的语句组。

#### 1.2.1 方法的语法结构

方法 = 方法头 + 方法体

* 方法头 = 修饰符 (alter) + 返回值类型 + 方法名 + 参数列表 (alter 参数类型、次序和数量)

方法签名 = 方法名 + 参数表

#### 1.2.2 参数的值传递

* 参数顺序匹配：次序和数量匹配，**类型要兼容 (无需显示转换)**
* 只有值传递
    * 参数类型是基本数据类型：不会对实参进行修改
    * 参数类型是对象时，传递的是对象的引用，可以对实参引用的对象进行修改，但是不能让实参引用新对象

#### 1.2.3 方法的重载 Overload

* 方法重载：在同一个类中的多个方法有相同的名称，但方法签名不同，编译器根据方法签名决定调用哪个方法。

    = 多个方法同名，参数列表不同

* 增加程序可读性

* 不能通过修饰符和返回值类型进行重载

* 如果一个方法调用有多个可能的匹配，编译器会选择最合适的匹配方法

    若编译器无法判断，则为**歧义调用**，会导致编译错误

### 1.3 递归

递归：直接或间接调用自身的方法

#### 1.3.1 递归的要点

* 定义递归方法时需要定义 递归的初始状态、初始状态的处理 和 递归调用
* 保证所有递归调用都能达到初始状态 (终止条件)，否则会发生无限递归，导致栈溢出
* 非初始状态：进行递归调用，对子问题求解

**尾递归：**递归调用是方法中最后执行的语句，且返回值不属于表达式的一部分

* 在返回时直接传回原始的调用者，而不用经过中间的调用者
* 使用尾递归代替普通的递归，可以在时间和空间方面带来显著提升

#### 1.3.2 递归的优缺点

优点：代码简洁，容易理解

缺点

* 时间、空间消耗大

    * 调用函数时参数的入栈出栈都要额外时间开销

    * 由于栈空间有限，递归调用次数太多可能导致调用栈溢出

* 如果子问题存在重叠，在不加记忆化的情况下，递归会产生重复计算

> 可以通过什么方式解决递归的缺点？

```jsx
/* 尾递归
 * 加记忆化，避免重复计算
 * 改用迭代实现
 */
```

## Ch 2 面向对象

### 2.1 面向对象的概念

#### 2.1.1 面向对象和面向过程

**面向过程**

* 将问题分解成步骤，然后按照步骤实现函数，执行时依次调用函数。
* 数据和对数据的操作是分离的。
* 优点：性能更高，不需要面向对象的实例化。
* 缺点：不容易维护、复用和扩展。

**面向对象**

* 将问题分解成对象，描述事物在解决问题的步骤中的行为。
* 对象与属性和行为是关联的。
* 优点：具有封装、继承、多态的特性，容易维护、复用和扩展，可以设计出低耦合的系统。
* 缺点：需要实例化对象，性能较低

#### 2.1.2 对象和类

对象

* 现实世界中可以明确标识的实体。
* 有自己独有的状态 (数据域的集合) 和行为 (方法的集合)。

类

* 定义同一类型对象的结构，是对具有相同特征的对象的抽象。
* 是一个模板，用来定义对象的数据域和方法。
* 可以从一个类创建多个对象，创建对象称为实例化。

### 2.2 构造方法

调用构造方法可以创建新对象。实际应用中，一般用于初始化。

#### 2.2.1 定义和调用构造方法

* 构造方法的名称必须和其所在类的名称相同
* 构造方法没有返回类型
* 构造方法可以被重载 (参数列表可以不同)
* 使用 `new` 调用构造方法创建对象

#### 2.2.2 默认构造方法

* 可以不显式声明 => 类中会隐性声明一个方法体为空的无参构造方法 (默认构造方法)

### 2.3 静态和实例

* 类成员：类中的成员变量、方法
* 使用 `static` 修饰的类成员是静态的类成员，不适用 `static` 修饰的即为实例的类成员

#### 2.3.1 静态和实例的区别

|          | 静态                         | 实例                               |
| -------- | ---------------------------- | ---------------------------------- |
| 外部调用 | 通过类名或对象名调用均可     | 只能通过对象名调用                 |
| 内部访问 | 静态方法只能访问静态的类成员 | 实例方法可以访问静态或实例的类成员 |

> 为什么静态方法不能访问实例的类成员呢?
>
> 原因：实例的类成员是依赖于具体对象（实例）的，而静态方法不依赖于任何实例，因此不存在静态方法直接或间接地访问实例或实例的类成员的情况。

#### 2.3.2 判断使用静态或实例

**类成员是否依赖于具体实例**

* 如果依赖于具体实例，类成员必须是实例
* 否则，应该被定义为静态类成员，例如 `Math` 类中的所有类成员都是静态的

### 2.4 初始化块

* 代码初始化块属于类成员
* 在 加载类 或 创建对象 时会隐式调用代码初始块
* 优点：减少多个构造器内的重复代码

#### 2.4.1 初始化块的分类

* **静态初始化块**：在**加载类**时被隐式调用

    ```java
    static {
      ...
    }
    ```

* **非静态初始化块**：在**创建对象**时被隐式调用

    ```java
    {
      ...
    }
    ```

#### 2.4.2 单个类的初始化块执行顺序

==静态初始化块 => 非静态初始化块 => 构造器==

如果有初始化块，则初始化块会在其他代码之前被执行

* 静态初始化块

    * 会在静态方法之前被执行

        => 静态初始化最先执行，且只执行一次，在`main`方法之前

* 非静态初始化块

    * 会在构造器和实例方法之前被执行

        => 每次创建对象都会执行

#### 2.4.3 存在继承关系的初始化块执行顺序

> 如果存在继承关系，则在对子类进行类的加载和创建对象时，也会对父类进行类的加载和创建对象。

执行顺序规则

1. 按照从父类到子类的顺序，依次执行每个类的静态初始化块。

2. 按照从父类到子类的顺序，对于每个类，依次执行非静态初始化块和构造器，直到所有类执行完毕。

### 2.5 关键字 this

* `this` 代表当前 (具体) 对象的引用
* 因为静态方法和静态初始化块不依赖于类的具体对象，所以 `this`静态方法和静态初始化块中不能使用 `this`

#### 2.5.1 `this` 引用隐藏变量

当方法 (包括构造方法)中有参数、局部变量和属性名相同时，需要用 `this` 引用对象的属性进行赋值。例：`this.name = name;`

如果没有重名，则可以省略属性名前的 `this`

#### 2.5.2 `this` 调用其他构造方法

* 可以在构造方法中通过 `this` 调用其他构造方法
* 用法：`this(params list)`，且必须出现在其他语句之前

### 2.6 可见性修饰符和数据域封装

可见性修饰符：控制对类成员的访问

* `public`, `private`, `protected`, 默认修饰符

#### 2.6.1 不同的可见性修饰符的含义

* `public` 无访问限制
* `private` ：类内访问
* 默认修饰符：包私访问、包内访问

#### 2.6.2 数据域封装

数据域封装：对数据域使用 `private` 修饰符，将数据域声明为私有域，不允许从类的外部修改。

* 使用 `private` 修饰数据域
* 编写 `get` 和 `set` 方法用于返回和设置数据域的值

### 2.7 字符串

`String`, `StringBuffer`, `StringBuilder`

#### 2.7.1 String

不可变类型，适用于字符串常量

* 使用字符数组存储，并使用 `final` 修饰 (final修饰的引用不可以指向其他对象)

* 数组声明为 private，且没有对外提供修改的方法，所以字符串对象无法修改

    => `String` 定义的字符串的值不可变

    => 每次对 `String` 的修改操作都会创建新的 `String` 对象

    => 效率低下，占用大量内存

#### 2.7.2 StringBuffer 和 StringBuilder

可变类型

* 都是 `AbstractStringBuilder` 的子类，
